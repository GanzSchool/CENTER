
# ‚ú® REFAKTOR√ÅL√ÅS: findEvenNumbers f√ºggv√©ny

---

### ‚úÖ Eredeti:

```javascript
function findEvenNumbers(numbers) {
  const evenNumbers = [];

  for (let i = 0; i < numbers.length; i++) {
    const number = numbers[i];

    if (number % 2 === 0) {
      evenNumbers.push(number);
    }
  }

  return evenNumbers;
}
```

---

## 1. l√©p√©s: `for` helyett `for...of`

Egyszer≈±bb ciklus, k√∂zvetlen√ºl az √©rt√©kekkel dolgozunk:

```javascript
function findEvenNumbers(numbers) {
  const evenNumbers = [];

  for (let number of numbers) {
    if (number % 2 === 0) {
      evenNumbers.push(number);
    }
  }

  return evenNumbers;
}
```

‚úÖ Nem kell indexelni (`numbers[i]`),  
‚úÖ r√∂videbb, olvashat√≥bb, tiszt√°bb k√≥d.

---

## 2. l√©p√©s: `filter()` haszn√°lata

A `filter()`-t pontosan az ilyen sz≈±r√©sre tal√°lt√°k ki:

```javascript
function findEvenNumbers(numbers) {
  return numbers.filter(number => number % 2 === 0);
}
```

‚úÖ Egyetlen sorban elv√©gezz√ºk a sz≈±r√©st,  
‚úÖ nincs sz√ºks√©g sem `if`-re, sem `push`-ra.

---

## 3. l√©p√©s: Arrow function

√âs v√©g√ºl: teljes moderniz√°l√°s arrow function form√°ban:

```javascript
const findEvenNumbers = numbers => numbers.filter(number => number % 2 === 0);
```

‚úÖ Tiszta, r√∂vid, teljesen **modern JS**  
‚úÖ Itt m√©g nincs method chaining, **de ez m√°r egy profi, egysoros f√ºggv√©ny**  
‚úÖ Ha k√©s≈ëbb `map()` vagy m√°s m≈±velet is kellene, r√∂gt√∂n **l√°ncolhat√≥** lenne ‚ûî method chaininggel!

---

## üéØ √ñsszefoglal√≥

| Verzi√≥ | K√≥dst√≠lus | Megjegyz√©s |
|:-------|:----------|:-----------|
| `for` + `push` | Alapszint | Kezd≈ëknek tanul√°shoz j√≥ |
| `for...of` | K√∂z√©phalad√≥ | Olvashat√≥bb ciklus |
| `filter()` | Halad√≥ | R√∂videbb, funkcion√°lis k√≥d |
| Arrow function + `filter()` | Profi | T√∂m√∂r, modern, azonnal tov√°bbf≈±zhet≈ë (method chaining-kompatibilis) |

---

Szeretn√©d, hogy √∂ssze√°ll√≠tsak egy kis ‚Äûrefaktor√°l√≥ k√©zik√∂nyvet‚Äù is ezekb≈ël az √°talak√≠t√°si mint√°kb√≥l